##### 缓冲池Buffer Pool

mysql是底层文件系统，查询数据需要io流，有一层buffer pool（缓冲池）将最常访问的数据存在缓存里，提高数据访问速度

###### 预读机制：

用户获取某一个数据时，mysql已经读取了一页的数据，每一页数据有16k，虽然只展示了一部分但是那一夜数据全部都已经加载出来了，拿取附近的数据时，只需要从缓冲池里取出即可，减少io读取

缺点：

- 数据访问间隔过小无法在实际访问之前预加载所需要数据，导致预读失效
- 缓存空间不足，缓存溢出或被替换掉导致预读失败
- 数据被频繁修改，数据经常发生修改，缓存的数据与预读的数据不同步

###### 冷热数据分离

将LRU链表分为两部分，一部分热数据区域，一部分冷数据区域

热数据：频繁访问的数据

冷数据：访问频率较低的数据

核心思想是：频繁访问的数据（热数据）保存在快速存储介质上，而不常访问的数据（冷数据）则迁移到较为廉价、容量较大的存储介质上。

数据生命周期管理：通过自动化策略，管理数据生命周期，自动将数据从热存储迁移到冷存储中

#### Explain用法

慢查询：执行时间较长或消耗系统资源较多的查询语句

##### id（掌握）

explain查询出来之后，id越大优先级越高，id越大，越优先被执行

##### select——type

查询的类型，主要是用于区别 普通查询、联合查询、子查询等的复杂查询

- SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION
-  PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY
-  SUBQUERY：在SELECT或WHERE列表中包含了子查询
-  DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询, 把结果放在临时表里。
-  UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED
-  UNION RESULT：从UNION表获取结果的SELECT
-  DEPENDENT SUBQUERY：依赖子查询是指子查询中的某些部分（如表名、列名等）需要依赖于外部查询中的值或条件。

##### table（了解）

显示着行数据是关于那张表的

衍生表：一般是<derived+id>

##### type(非常重要的指标)

system > const > eq_ref > ref > range > index>all

按照上面的顺序，SQL从 好变为坏。

- Const：表示通过索引一次就找到了const用于比较primary key或者unique索引。
- Eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。
- Ref: 非唯一性索引扫描，返回匹配某个单独值的所有行，可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体.
- range: 只检索给定范围的行,使用一个索引来选择行。
- Index:  称之为覆盖索引。
- ALL: 将遍历全表以找到匹配的行,没有使用到索引。

##### possible keys(了解)

查询是否使用查询，如果用了显示有几个

##### key（掌握）

显示实际使用的索引

若使用了索引覆盖，则索引与查询的select字段重叠

##### key_len(掌握)

- 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。
- key_len显示的值为索引字段的最大可能长度，并非实际使用长度。
- 在不损失精确性的情况下，长度越短越好

##### ref(掌握)

ref 表示使用到了哪些索引，key 表示使用到了索引，索引的具体情况没有说，需要查看ref 才能够知道。

##### rows（了解）

查询这一条数据需要查询多少条数据

##### extra（重点）

创建一个复合索引c1，c2，c3

最好的情况是都用了

（1）Using filesort索引使用时有断层，无法正常使用这个索引

（2）Using temporary，使用临时表保存中间结果，

（3）USING index使用索引查询

索引覆盖当查询的数据正好在索引上时不需要回表直接返回

当同时使用using where时索引用来查找符合条件的记录，where来进一步过滤筛选符合条件的数据

（4）Using where

（5）using join buffer 使用了连接缓存

（6） impossible where  ，where子句的值总是false，不能用来获取任何元素例如一个name字段同时等于两个不同的名字，或者一个age同时大于和小于一个数，

#### sql优化方案

##### 全字段匹配

联合索引全部用到，越多越好

##### 最佳左前缀法则

在创建索引时用的什么顺序，也必须用那个顺序来，才可以正确使用联合索引

##### 索引列上不计算

在索引上做任何操作（计算、函数、(自动or手动)类型转换）等，会导致之前创建的索引失效转而全表查询

##### 不能适用范围条件右边的列

在联合索引中如果有一个字段是范围查询那么它右边的字段无法是正常使用，可能需要采取回表的方法获取其他数据

##### 尽量使用覆盖索引

尽量精确查找，查询什么就写什么， 这样可以提高查询效率，尽量避免大量使用select *

##### 使用（！=或者<>）时无法使用索引

使用这个需要将(!=或者<>)的数据 无法快速排除某个值，需要通过全表扫描出来，而非索引扫描，效率低下

##### null和notnull对sql的影响

尽量设置为非空（not null）在计算工资那部分如果有null的话+null=null

##### like以通配符开头('%abc...')mysql索引失效

##### 字符串不加单引号索引失效 （底层使用数据类型转换）

索引是基于特定数据类型的，数据类型不匹配

导致MySQL执行类型转换，从而影响索引的使用，并可能导致全表扫描

##### 少用or,用它来连接时会索引失效

可以使用union 替代 or 
